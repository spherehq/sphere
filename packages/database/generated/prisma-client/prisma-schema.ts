// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
  type AggregatePost {
    count: Int!
  }

  type AggregatePostMetadata {
    count: Int!
  }

  type BatchPayload {
    count: Long!
  }

  scalar DateTime

  scalar Json

  scalar Long

  type Mutation {
    createPost(data: PostCreateInput!): Post!
    updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
    updateManyPosts(
      data: PostUpdateManyMutationInput!
      where: PostWhereInput
    ): BatchPayload!
    upsertPost(
      where: PostWhereUniqueInput!
      create: PostCreateInput!
      update: PostUpdateInput!
    ): Post!
    deletePost(where: PostWhereUniqueInput!): Post
    deleteManyPosts(where: PostWhereInput): BatchPayload!
    createPostMetadata(data: PostMetadataCreateInput!): PostMetadata!
    updateManyPostMetadatas(
      data: PostMetadataUpdateManyMutationInput!
      where: PostMetadataWhereInput
    ): BatchPayload!
    deleteManyPostMetadatas(where: PostMetadataWhereInput): BatchPayload!
  }

  enum MutationType {
    CREATED
    UPDATED
    DELETED
  }

  interface Node {
    id: ID!
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type Post {
    id: ID!
    title: String!
    content: Json!
    slug: String!
    timeToRead: Int!
    isPublished: Boolean!
    publishedAt: DateTime
    createdAt: DateTime!
    updatedAt: DateTime!
    status: POST_STATUS!
    metadata: PostMetadata!
  }

  enum POST_STATUS {
    PUBLISHED
    DRAFT
    ARCHIVED
    SYNCING
  }

  type PostConnection {
    pageInfo: PageInfo!
    edges: [PostEdge]!
    aggregate: AggregatePost!
  }

  input PostCreateInput {
    title: String!
    content: Json!
    slug: String!
    timeToRead: Int
    isPublished: Boolean
    publishedAt: DateTime
    status: POST_STATUS
    metadata: PostMetadataCreateOneInput!
  }

  type PostEdge {
    node: Post!
    cursor: String!
  }

  type PostMetadata {
    fileHash: String!
    filename: String
  }

  type PostMetadataConnection {
    pageInfo: PageInfo!
    edges: [PostMetadataEdge]!
    aggregate: AggregatePostMetadata!
  }

  input PostMetadataCreateInput {
    fileHash: String!
    filename: String
  }

  input PostMetadataCreateOneInput {
    create: PostMetadataCreateInput
  }

  type PostMetadataEdge {
    node: PostMetadata!
    cursor: String!
  }

  enum PostMetadataOrderByInput {
    fileHash_ASC
    fileHash_DESC
    filename_ASC
    filename_DESC
    id_ASC
    id_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
  }

  type PostMetadataPreviousValues {
    fileHash: String!
    filename: String
  }

  type PostMetadataSubscriptionPayload {
    mutation: MutationType!
    node: PostMetadata
    updatedFields: [String!]
    previousValues: PostMetadataPreviousValues
  }

  input PostMetadataSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: PostMetadataWhereInput
    AND: [PostMetadataSubscriptionWhereInput!]
    OR: [PostMetadataSubscriptionWhereInput!]
    NOT: [PostMetadataSubscriptionWhereInput!]
  }

  input PostMetadataUpdateDataInput {
    fileHash: String
    filename: String
  }

  input PostMetadataUpdateManyMutationInput {
    fileHash: String
    filename: String
  }

  input PostMetadataUpdateOneRequiredInput {
    create: PostMetadataCreateInput
    update: PostMetadataUpdateDataInput
    upsert: PostMetadataUpsertNestedInput
  }

  input PostMetadataUpsertNestedInput {
    update: PostMetadataUpdateDataInput!
    create: PostMetadataCreateInput!
  }

  input PostMetadataWhereInput {
    fileHash: String
    fileHash_not: String
    fileHash_in: [String!]
    fileHash_not_in: [String!]
    fileHash_lt: String
    fileHash_lte: String
    fileHash_gt: String
    fileHash_gte: String
    fileHash_contains: String
    fileHash_not_contains: String
    fileHash_starts_with: String
    fileHash_not_starts_with: String
    fileHash_ends_with: String
    fileHash_not_ends_with: String
    filename: String
    filename_not: String
    filename_in: [String!]
    filename_not_in: [String!]
    filename_lt: String
    filename_lte: String
    filename_gt: String
    filename_gte: String
    filename_contains: String
    filename_not_contains: String
    filename_starts_with: String
    filename_not_starts_with: String
    filename_ends_with: String
    filename_not_ends_with: String
    AND: [PostMetadataWhereInput!]
    OR: [PostMetadataWhereInput!]
    NOT: [PostMetadataWhereInput!]
  }

  enum PostOrderByInput {
    id_ASC
    id_DESC
    title_ASC
    title_DESC
    content_ASC
    content_DESC
    slug_ASC
    slug_DESC
    timeToRead_ASC
    timeToRead_DESC
    isPublished_ASC
    isPublished_DESC
    publishedAt_ASC
    publishedAt_DESC
    createdAt_ASC
    createdAt_DESC
    updatedAt_ASC
    updatedAt_DESC
    status_ASC
    status_DESC
  }

  type PostPreviousValues {
    id: ID!
    title: String!
    content: Json!
    slug: String!
    timeToRead: Int!
    isPublished: Boolean!
    publishedAt: DateTime
    createdAt: DateTime!
    updatedAt: DateTime!
    status: POST_STATUS!
  }

  type PostSubscriptionPayload {
    mutation: MutationType!
    node: Post
    updatedFields: [String!]
    previousValues: PostPreviousValues
  }

  input PostSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: PostWhereInput
    AND: [PostSubscriptionWhereInput!]
    OR: [PostSubscriptionWhereInput!]
    NOT: [PostSubscriptionWhereInput!]
  }

  input PostUpdateInput {
    title: String
    content: Json
    slug: String
    timeToRead: Int
    isPublished: Boolean
    publishedAt: DateTime
    status: POST_STATUS
    metadata: PostMetadataUpdateOneRequiredInput
  }

  input PostUpdateManyMutationInput {
    title: String
    content: Json
    slug: String
    timeToRead: Int
    isPublished: Boolean
    publishedAt: DateTime
    status: POST_STATUS
  }

  input PostWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    title: String
    title_not: String
    title_in: [String!]
    title_not_in: [String!]
    title_lt: String
    title_lte: String
    title_gt: String
    title_gte: String
    title_contains: String
    title_not_contains: String
    title_starts_with: String
    title_not_starts_with: String
    title_ends_with: String
    title_not_ends_with: String
    slug: String
    slug_not: String
    slug_in: [String!]
    slug_not_in: [String!]
    slug_lt: String
    slug_lte: String
    slug_gt: String
    slug_gte: String
    slug_contains: String
    slug_not_contains: String
    slug_starts_with: String
    slug_not_starts_with: String
    slug_ends_with: String
    slug_not_ends_with: String
    timeToRead: Int
    timeToRead_not: Int
    timeToRead_in: [Int!]
    timeToRead_not_in: [Int!]
    timeToRead_lt: Int
    timeToRead_lte: Int
    timeToRead_gt: Int
    timeToRead_gte: Int
    isPublished: Boolean
    isPublished_not: Boolean
    publishedAt: DateTime
    publishedAt_not: DateTime
    publishedAt_in: [DateTime!]
    publishedAt_not_in: [DateTime!]
    publishedAt_lt: DateTime
    publishedAt_lte: DateTime
    publishedAt_gt: DateTime
    publishedAt_gte: DateTime
    createdAt: DateTime
    createdAt_not: DateTime
    createdAt_in: [DateTime!]
    createdAt_not_in: [DateTime!]
    createdAt_lt: DateTime
    createdAt_lte: DateTime
    createdAt_gt: DateTime
    createdAt_gte: DateTime
    updatedAt: DateTime
    updatedAt_not: DateTime
    updatedAt_in: [DateTime!]
    updatedAt_not_in: [DateTime!]
    updatedAt_lt: DateTime
    updatedAt_lte: DateTime
    updatedAt_gt: DateTime
    updatedAt_gte: DateTime
    status: POST_STATUS
    status_not: POST_STATUS
    status_in: [POST_STATUS!]
    status_not_in: [POST_STATUS!]
    metadata: PostMetadataWhereInput
    AND: [PostWhereInput!]
    OR: [PostWhereInput!]
    NOT: [PostWhereInput!]
  }

  input PostWhereUniqueInput {
    id: ID
    slug: String
  }

  type Query {
    post(where: PostWhereUniqueInput!): Post
    posts(
      where: PostWhereInput
      orderBy: PostOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Post]!
    postsConnection(
      where: PostWhereInput
      orderBy: PostOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): PostConnection!
    postMetadatas(
      where: PostMetadataWhereInput
      orderBy: PostMetadataOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [PostMetadata]!
    postMetadatasConnection(
      where: PostMetadataWhereInput
      orderBy: PostMetadataOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): PostMetadataConnection!
    node(id: ID!): Node
  }

  type Subscription {
    post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
    postMetadata(
      where: PostMetadataSubscriptionWhereInput
    ): PostMetadataSubscriptionPayload
  }
`
